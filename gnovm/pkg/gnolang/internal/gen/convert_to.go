package main

import (
	"fmt"
	"iter"
	"math/big"
	"strconv"
	"strings"
)

const header = `// Code generated by ./internal/gen/convert_to.go. DO NOT EDIT.

package gnolang

func convertTo(alloc *Allocator, store Store, tv *TypedValue, t Type, isConst bool) {
	switch tv.T.Kind()<<8 | t.Kind() {
`

const footer = "}\n"

type combination struct {
	src  string
	dst  string
	cond string
}

func join(ss ...[]string) []string {
	dst := make([]string, len(ss[0]))
	for _, s := range ss {
		dst = append(dst, s...)
	}
	return dst
}

func main() {
	bld := new(strings.Builder)
	bld.WriteString(header)
	for comb := range gen() {
		fmt.Fprintf(bld, "\tcase %s<<8 | %s:\n", toKind(comb.src), toKind(comb.dst))
		if comb.cond != "" {
			bld.WriteString("\t\tif isConst {\n")
			bld.WriteString("\t\t\tif v := tv.Get" + titled(comb.src) + "(); ")
			bld.WriteString(comb.cond)
			bld.WriteString(" {\n\t\t\t\t")
			fmt.Fprintf(bld, `panic(fmt.Sprintf("cannot use %s constant %%v as %s value", ))`)
			// TODO
		}
	}
}

var (
	ints = [...]string{
		"int",
		"int8",
		"int16",
		"int32",
		"int64",
	}
	uints = [...]string{
		"uint",
		"uint8",
		"uint16",
		"uint32",
		"uint64",
	}
	floats = [...]string{
		"float32",
		"float64",
	}
)

func typeRange(s string) (min, max *big.Int) {
	var bits int
	if bits, _ = strconv.Atoi(s[len(s)-2:]); bits != 0 {
	} else if bits, _ = strconv.Atoi(s[len(s)-1:]); bits != 0 {
	} else {
		bits = 64
	}
	if s[0] == 'u' {
		max = big.NewInt(1)
		max.Lsh(max, uint(bits))
		max.Sub(max, big.NewInt(1))
		min = big.NewInt(0)
		return
	} else {
		max = big.NewInt(1)
		max.Lsh(max, uint(bits-1))
		max.Sub(max, big.NewInt(1))
		min = big.NewInt(-1)
		min.Lsh(min, uint(bits-1))
		return
	}
}

func titled(s string) string {
	return string(s[0]-'a'+'A') + string(s[1:])
}

func toKind(s string) string {
	return titled(s) + "Kind"
}

func gen() iter.Seq[combination] {
	allNumerics := join(ints[:], uints[:], floats[:])
	return func(yield func(combination) bool) {
		var c combination
		for _, c.src = range join(ints[:], uints[:]) {
			for _, c.dst = range allNumerics {
				if c.src == c.dst {
					// src == dst is handled outside of this function.
					continue
				}
				c.cond = ""

				smin, smax := typeRange(c.src)
				dmin, dmax := typeRange(c.dst)
				if smin.Cmp(dmin) == -1 {
					c.cond = "v < " + dmin.String()
				}
				if smax.Cmp(dmax) == 1 {
					if c.cond != "" {
						c.cond += " && "
					}
					c.cond = "v > " + dmax.String()
				}

				if !yield(c) {
					return
				}
			}
		}
	}
}
